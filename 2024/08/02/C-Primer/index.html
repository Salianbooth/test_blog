<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>C++ Primer | Alan Chen&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="C++ PrimerChapter 02      Variables and Basic TypesTable 2.1. C++: Arithmetic Types Signed and Unsigned Types Except for bool and the extended character types, the integral types may be signed or unsi">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer">
<meta property="og:url" content="https://salianbooth.github.io/2024/08/02/C-Primer/index.html">
<meta property="og:site_name" content="Alan Chen&#39;s blog">
<meta property="og:description" content="C++ PrimerChapter 02      Variables and Basic TypesTable 2.1. C++: Arithmetic Types Signed and Unsigned Types Except for bool and the extended character types, the integral types may be signed or unsi">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202408021209868.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202406262056997.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202406262101025.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407081455638.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407081458843.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407081459202.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407131024908.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407131029738.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407181759430.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407181808544.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407181848600.png">
<meta property="og:image" content="https://gitee.com/salianbooth/picture/raw/master/202407181849206.png">
<meta property="article:published_time" content="2024-08-02T04:06:42.000Z">
<meta property="article:modified_time" content="2024-08-05T03:50:37.194Z">
<meta property="article:author" content="Salianbooth">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="Markdown">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/salianbooth/picture/raw/master/202408021209868.png">
  
    <link rel="alternate" href="/atom.xml" title="Alan Chen's blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="referrer" content="no-referrer" />
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/background.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Alan Chen's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/1.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Alan Chen </div>
      <div class="dot"></div>
      <div class="subtitle">人生、二十七で死ねるならロックンロールは僕を救った </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Salianbooth" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Categories</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/book/">
                book
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li></ul>
    </div>
  </div>


    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-C-Primer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        C++ Primer
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-08-02T04:06:42.000Z" itemprop="datePublished">2024-08-02</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a href="/categories/book/" class="meta-cate">book</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            32k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h1 id="C-Primer"><a href="#C-Primer" class="headerlink" title="C++ Primer"></a>C++ Primer</h1><h1 id="Chapter-02-Variables-and-Basic-Types"><a href="#Chapter-02-Variables-and-Basic-Types" class="headerlink" title="Chapter 02      Variables and Basic Types"></a>Chapter 02      Variables and Basic Types</h1><h2 id="Table-2-1-C-Arithmetic-Types"><a href="#Table-2-1-C-Arithmetic-Types" class="headerlink" title="Table 2.1. C++: Arithmetic Types"></a>Table 2.1. C++: Arithmetic Types</h2><p><img src="https://gitee.com/salianbooth/picture/raw/master/202408021209868.png" alt="Clip_2024-06-22_16-18-35"></p>
<h4 id="Signed-and-Unsigned-Types"><a href="#Signed-and-Unsigned-Types" class="headerlink" title="Signed and Unsigned Types"></a>Signed and Unsigned Types</h4><ul>
<li><strong>Except for bool and the extended character types, the integral types may be signed or unsigned. A signed type represents negative or positive numbers (including zero); an unsigned type represents only values greater than or equal to zero. The types int, short, long, and long long are all signed. We obtain the corresponding unsigned type by adding unsigned to the type, such as unsigned long. The type unsigned int may be abbreviated as unsigned.</strong></li>
</ul>
<h4 id="2-1-3-Literals-字面值常量"><a href="#2-1-3-Literals-字面值常量" class="headerlink" title="2.1.3. Literals (字面值常量)"></a>2.1.3. Literals (字面值常量)</h4><ul>
<li>A value, such as 42, is known as a literal because its value self-evident. Every literal has a type. The form and value of a literal determine its type.20<br>$$<br>20 &#x2F;* decimal <em>&#x2F; 024 &#x2F;</em> octal <em>&#x2F; 0x14 &#x2F;</em> hexadecimal *&#x2F;<br>$$</li>
</ul>
<h5 id="Character-and-Character-String-Literals-字符和字符串字面值"><a href="#Character-and-Character-String-Literals-字符和字符串字面值" class="headerlink" title="Character and Character String Literals(字符和字符串字面值)"></a>Character and Character String Literals(字符和字符串字面值)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="comment">// character literal</span></span><br><span class="line"><span class="string">&quot;Hello World!&quot;</span> <span class="comment">// string literal</span></span><br></pre></td></tr></table></figure>



<h5 id="Escape-Sequences（转义序列）"><a href="#Escape-Sequences（转义序列）" class="headerlink" title="Escape Sequences（转义序列）"></a>Escape Sequences（转义序列）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">newline \n </span><br><span class="line">horizontal tab \t </span><br><span class="line">alert (bell) \a</span><br><span class="line">vertical tab \v </span><br><span class="line">backspace \b </span><br><span class="line">double quote \&quot;</span><br><span class="line">backslash \\ </span><br><span class="line">question mark \? </span><br><span class="line">single quote \&#x27;</span><br><span class="line">carriage return \r </span><br><span class="line">formfeed \f</span><br></pre></td></tr></table></figure>

<h2 id="2-2-2-Variable-Declarations-and-Definitions"><a href="#2-2-2-Variable-Declarations-and-Definitions" class="headerlink" title="2.2.2. Variable Declarations and Definitions"></a>2.2.2. Variable Declarations and Definitions</h2><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>顶层 <code>const</code> 是指用在指针本身上时，即指针本身是常量。它决定了指针本身是否可以被修改。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;x;  <span class="comment">// ptr 是一个常量指针，指向 x，不能改变 ptr 指向的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作合法</span></span><br><span class="line">*ptr = <span class="number">20</span>;  <span class="comment">// 修改 ptr 指向的值为 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作不合法，会导致编译错误</span></span><br><span class="line"><span class="comment">// ptr = nullptr;  // 错误：ptr 是常量指针，不能改变其指向的地址</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ptr</code> 是一个常量指针，意味着你可以通过 <code>ptr</code> 修改它指向的值（<code>*ptr = 20;</code>），但不能修改 <code>ptr</code> 本身指向的地址（<code>ptr = nullptr;</code> 是非法的）。</p>
<p>底层 <code>const</code> 则是指指针指向的对象是常量，即指针所指向的值不能被修改。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr = &amp;x;  <span class="comment">// ptr 是一个指向常量整数的指针，不能通过 ptr 修改 x 的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作合法</span></span><br><span class="line"><span class="comment">// int y = *ptr;  // 可以读取 ptr 指向的值，即 x 的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作不合法，会导致编译错误</span></span><br><span class="line"><span class="comment">// *ptr = 20;  // 错误：ptr 指向的是常量，不能修改其指向的值</span></span><br></pre></td></tr></table></figure>

<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul>
<li>**顶层 <code>const</code>**：修饰的是指针本身，表示指针本身是常量，不可修改指向的地址。</li>
<li>**底层 <code>const</code>**：修饰的是指针指向的对象，表示指针指向的值是常量，不可修改该值。</li>
</ul>
<p>理解这两个概念对于正确理解和使用 C++ 中的 <code>const</code> 修饰符非常重要，特别是在处理指针和函数参数时，它们可以帮助你确保代码的正确性和安全性。</p>
<h1 id="Chapter-3-Strings-Vectors-and-Arrays"><a href="#Chapter-3-Strings-Vectors-and-Arrays" class="headerlink" title="Chapter 3. Strings, Vectors, and Arrays"></a>Chapter 3. Strings, Vectors, and Arrays</h1><h2 id="3-4-1-Using-Iterators"><a href="#3-4-1-Using-Iterators" class="headerlink" title="3.4.1. Using Iterators"></a>3.4.1. Using Iterators</h2><h3 id="Iterator-Operations"><a href="#Iterator-Operations" class="headerlink" title="Iterator Operations"></a>Iterator Operations</h3><p><img src="https://gitee.com/salianbooth/picture/raw/master/202406262056997.png" alt="Clip_2024-06-26_20-56-56"></p>
<p>迭代器就像是对于STL标准库中的String和Vector这些对象的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>(); <span class="comment">// it1 has type vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>(); <span class="comment">// it2 has type vector&lt;int&gt;::const_iterator</span></span><br><span class="line"></span><br><span class="line">(*it).<span class="built_in">empty</span>() <span class="comment">// dereferences it and calls the member empty on the resulting</span></span><br><span class="line">object</span><br><span class="line">*it.<span class="built_in">empty</span>() <span class="comment">// error: attempts to fetch the member named empty from it</span></span><br><span class="line"> 			<span class="comment">// but it is an iterator and has no member named empty</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// print each line in text up to the first blank line</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = text.<span class="built_in">cbegin</span>();</span><br><span class="line"> it != text.<span class="built_in">cend</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); ++it) cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>end()指向的是最后一个元素的下一个指针</p>
<p><strong>注意：迭代器与迭代器之间没有加法运算</strong></p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202406262101025.png" alt="Clip_2024-06-26_21-01-08"></p>
<h2 id="3-5-Arrays"><a href="#3-5-Arrays" class="headerlink" title="3.5. Arrays"></a>3.5. Arrays</h2><p>Exercise 3.27: Assuming txt_size is a function that takes no arguments and returns an int value, which of the following definitions are illegal? Explain why.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> buf_size = <span class="number">1024</span>;</span><br><span class="line">(a) <span class="type">int</span> ia[buf_size];</span><br><span class="line">(b) <span class="type">int</span> ia[<span class="number">4</span> * <span class="number">7</span> - <span class="number">14</span>];</span><br><span class="line">(c) <span class="type">int</span> ia[<span class="built_in">txt_size</span>()];</span><br><span class="line">(d) <span class="type">char</span> st[<span class="number">11</span>] = <span class="string">&quot;fundamental&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>(a)</strong> 非法，因为 <code>buf_size</code> 不是编译时常量。</li>
<li><strong>(b)</strong> 合法，因为 <code>4 * 7 - 14</code> 是编译时常量。</li>
<li><strong>(c)</strong> 非法，因为 <code>txt_size()</code> 是函数调用，不能在编译时确定其返回值。</li>
<li><strong>(d)</strong> 非法，因为数组 <code>st</code> 的大小不足以容纳字符串 <code>&quot;fundamental&quot;</code> 包括其末尾的空字符。</li>
</ul>
<p>注意，在自己电脑的时候会显示有的合法，那是因为编译器拓展，要避免使用这样的非标准特性，因为这可能会在其他电脑上运行失效。</p>
<h1 id="Chapter-4-表达式"><a href="#Chapter-4-表达式" class="headerlink" title="Chapter 4 表达式"></a>Chapter 4 表达式</h1><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><p><strong>定义</strong></p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202407081455638.png" alt="Clip_2024-07-08_14-55-44"></p>
<p><strong>重载运算符</strong></p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202407081458843.png" alt="Clip_2024-07-08_14-58-57"></p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202407081459202.png" alt="Clip_2024-07-08_14-59-04"></p>
<h1 id="Chapter-6-函数"><a href="#Chapter-6-函数" class="headerlink" title="Chapter 6 函数"></a>Chapter 6 函数</h1><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>​	<strong>形参出现在函数定义的地方，形参列表可以包含0个、1个或多个 形参，多个形参之间以逗号分隔。形参规定了一个函数所接受数据的 类型和数量。 实参出现在函数调用的地方，实参的数量与形参一样多。实参的 主要作用是初始化形参，并且这种初始化过程是一一对应的，即第一 个实参初始化第一个形参、第二个实参初始化第二个形参，以此类 推。实参的类型必须与对应的形参类型匹配。</strong></p>
<p><strong>形参、局部变量以及局部静态变量</strong></p>
<ul>
<li>形参是一种自动对象，函数开始时为形参申请内存空间，我们 用调用函数时提供的实参初始化形参对应的自动对象。</li>
<li>普通变量对应的自动对象也容易理解，我们在定义该变量的语 句处创建自动对象，如果定义语句提供了初始值，则用该值初始化； 否则，执行默认初始化。当该变量所在的块结束后，变量失效。</li>
<li>局部静态变量比较特殊，它的生命周期贯穿函数调用及之后的 时间。局部静态变量对应的对象称为局部静态对象，它的生命周期从 定义语句处开始，直到程序结束才终止。static</li>
</ul>
<h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><h3 id="const-形参和实参"><a href="#const-形参和实参" class="headerlink" title="const 形参和实参"></a>const 形参和实参</h3><p>终于知道那些函数形参里面为什么会要有const</p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202407131024908.png" alt="Clip_2024-07-13_10-24-06"></p>
<p>错误原因：第二个fcn是第一个的重载，因为我们在调用第一个fcn函数时，能传入const int 和 int 着两种类型的参数，所以这两个函数被认为是同一个函数</p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202407131029738.png" alt="Clip_2024-07-13_10-29-43"></p>
<h3 id="main：-处理命令行选项"><a href="#main：-处理命令行选项" class="headerlink" title="main： 处理命令行选项"></a>main： 处理命令行选项</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>**<code>int argc</code>**：<ul>
<li><code>argc</code> 是一个整数参数，表示命令行参数的数量（argument count）。它至少为 1，因为第一个参数是程序的名称（即可执行文件的路径）。</li>
</ul>
</li>
<li><strong><code>char *argv[]</code></strong> 或 **<code>char **argv</code>**：<ul>
<li><code>argv</code> 是一个指向字符指针（<code>char*</code>）数组的指针。这些字符指针指向每个命令行参数的字符串。<code>argv[0]</code> 指向程序的名称，<code>argv[1]</code>、<code>argv[2]</code> 等依次指向传递给程序的其他参数</li>
</ul>
</li>
</ol>
<h2 id="6-5-内联函数"><a href="#6-5-内联函数" class="headerlink" title="6.5 内联函数"></a>6.5 内联函数</h2><p>​	内联函数（inline function）是 C++ 中的一种优化手段，通过将函数调用替换为函数代码，从而减少函数调用的开销。内联函数使用 inline 关键字声明，编译器会在合适的情况下将其展开到调用处。以下是内联函数的详细讲解及其使用场景。</p>
<h3 id="什么是内联函数"><a href="#什么是内联函数" class="headerlink" title="什么是内联函数"></a>什么是内联函数</h3><p>内联函数是一种建议编译器在调用处展开的函数。与普通函数不同，内联函数在编译时将其代码直接插入到调用点，从而避免了函数调用的开销（如栈操作、跳转等）。</p>
<h3 id="定义内联函数"><a href="#定义内联函数" class="headerlink" title="定义内联函数"></a>定义内联函数</h3><p>内联函数通常在类定义中实现，也可以在类外定义时使用 <code>inline</code> 关键字。以下是两种方式的示例：</p>
<h4 id="类内定义"><a href="#类内定义" class="headerlink" title="类内定义"></a>类内定义</h4><p>在类内部定义的成员函数，默认情况下是内联函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">public:</span><br><span class="line">    int getValue() const &#123; return value; &#125; // 内联函数</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="类外定义"><a href="#类外定义" class="headerlink" title="类外定义"></a>类外定义</h4><p>在类外部定义时，需要显式使用 <code>inline</code> 关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">public:</span><br><span class="line">    int getValue() const;</span><br><span class="line">private:</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline int Example::getValue() const &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联函数的优点"><a href="#内联函数的优点" class="headerlink" title="内联函数的优点"></a>内联函数的优点</h3><ol>
<li>消除函数调用开销:<ul>
<li>内联函数将函数代码插入到调用处，消除了参数压栈、跳转和返回等函数调用开销。</li>
</ul>
</li>
<li>有助于编译器优化：<ul>
<li>内联展开可以使编译器更好地优化代码，例如消除不必要的变量、合并代码块等。</li>
</ul>
</li>
</ol>
<h3 id="内联函数的缺点"><a href="#内联函数的缺点" class="headerlink" title="内联函数的缺点"></a>内联函数的缺点</h3><ol>
<li><strong>代码膨胀</strong>：<ul>
<li>如果内联函数体较大且被多次调用，会导致生成的二进制代码膨胀，增加可执行文件的大小。</li>
</ul>
</li>
<li><strong>内联并非强制</strong>：<ul>
<li>内联是对编译器的建议，编译器可以选择忽略。如果函数体较大或编译器认为展开不合适，可能不会内联展开。</li>
</ul>
</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li><strong>简单、频繁调用的函数</strong>：适用于函数体小且频繁调用的函数，如访问器（getter）和设置器（setter）。</li>
<li><strong>时间关键代码</strong>：在性能要求较高的代码中，可以使用内联函数减少函数调用开销。</li>
</ul>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol>
<li>避免过度使用:<ul>
<li>不要将大型函数声明为内联函数，否则会导致代码膨胀。</li>
</ul>
</li>
<li>递归函数:<ul>
<li>递归函数通常不适合作为内联函数，因为展开递归调用会导致无限膨胀。</li>
</ul>
</li>
</ol>
<h1 id="Chapter-7-类"><a href="#Chapter-7-类" class="headerlink" title="Chapter 7 类"></a>Chapter 7 类</h1><h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>就是能使用private里面的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> SalesData <span class="title">add</span><span class="params">(<span class="type">const</span> SalesData&amp;,<span class="type">const</span> SalesData&amp;)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream&amp;,<span class="type">const</span> SalesData&amp;)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream&amp;,SalesData&amp;)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="7-3类的其他特性"><a href="#7-3类的其他特性" class="headerlink" title="7.3类的其他特性"></a>7.3类的其他特性</h2><h3 id="不同的构造函数"><a href="#不同的构造函数" class="headerlink" title="不同的构造函数"></a>不同的构造函数</h3><ol>
<li><p><strong>构造函数体内赋值</strong>（你之前见过的形式）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SalesData</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;bookNo = s;</span><br><span class="line">    <span class="keyword">this</span>-&gt;units_sold = n;</span><br><span class="line">    <span class="keyword">this</span>-&gt;renvenue = p * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>成员初始化列表</strong>（你当前的代码）：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SalesData</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) :</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">renvenue</span>(p * n) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员初始化列表的优势和必要性"><a href="#成员初始化列表的优势和必要性" class="headerlink" title="成员初始化列表的优势和必要性"></a>成员初始化列表的优势和必要性</h4><p>成员初始化列表在构造函数中用来初始化成员变量，而不是在构造函数体内进行赋值。成员初始化列表有几个重要的优势和必要性：</p>
<ol>
<li><p><strong>效率</strong>：</p>
<ul>
<li>成员初始化列表直接初始化成员变量，而不是先调用默认构造函数再赋值。因此，对于复杂类型，成员初始化列表通常更高效。</li>
</ul>
</li>
<li><p><strong>常量成员</strong>：</p>
<ul>
<li>对于 <code>const</code> 成员变量（如你的 <code>bookNo</code>），必须在初始化列表中进行初始化，因为常量只能初始化一次，之后不能再赋值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const std::string bookNo;</span><br><span class="line">SalesData(const std::string &amp;s) : bookNo(s) &#123;&#125; // 必须使用初始化列表</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用成员</strong>：</p>
<ul>
<li>对于引用成员变量，也必须在初始化列表中进行初始化，因为引用必须在创建时绑定到一个对象，之后不能再更改。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const std::string &amp;bookNo;</span><br><span class="line">SalesData(const std::string &amp;s) : bookNo(s) &#123;&#125; // 必须使用初始化列表</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化顺序</strong>：</p>
<ul>
<li>成员初始化列表按照成员在类中声明的顺序初始化，而不是列表中的顺序。这样可以避免成员之间依赖关系带来的问题。</li>
</ul>
</li>
</ol>
<h4 id="具体示例解释"><a href="#具体示例解释" class="headerlink" title="具体示例解释"></a>具体示例解释</h4><p>你的类定义使用了成员初始化列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SalesData(const std::string &amp;s, unsigned n, double p) :</span><br><span class="line">    bookNo(s), units_sold(n), renvenue(p * n) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码的意思是：</p>
<ul>
<li><code>bookNo(s)</code>：使用参数 <code>s</code> 初始化成员变量 <code>bookNo</code>。</li>
<li><code>units_sold(n)</code>：使用参数 <code>n</code> 初始化成员变量 <code>units_sold</code>。</li>
<li><code>renvenue(p * n)</code>：使用 <code>p * n</code> 初始化成员变量 <code>renvenue</code>。</li>
</ul>
<p>如果使用构造函数体内赋值的方式，代码会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SalesData(const std::string &amp;s, unsigned n, double p) &#123;</span><br><span class="line">    bookNo = s;</span><br><span class="line">    units_sold = n;</span><br><span class="line">    renvenue = p * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这在大多数情况下也能工作，但对于 <code>const</code> 或引用成员变量会导致编译错误，并且在效率上通常不如成员初始化列表。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>成员初始化列表直接在成员变量创建时进行初始化，通常更高效，并且是初始化 <code>const</code> 和引用成员的唯一方法。</li>
<li>构造函数体内赋值方式在成员变量已经被默认构造函数初始化后再进行赋值，可能会产生额外的开销，且不能用于 <code>const</code> 和引用成员</li>
</ul>
<h3 id="set和get函数"><a href="#set和get函数" class="headerlink" title="set和get函数"></a>set和get函数</h3><p>在C++中的类与对象中，<code>set</code>和<code>get</code>函数（有时称为“setter”和“getter”函数）通常用于访问和修改类的私有数据成员。这些函数提供了一种受控的方式来操作类的成员变量，从而增强了封装性和数据完整性。</p>
<h4 id="set函数"><a href="#set函数" class="headerlink" title="set函数"></a><code>set</code>函数</h4><p><code>set</code>函数（或setter函数）用于设置类的私有数据成员的值。通过使用<code>set</code>函数，你可以控制对成员变量的修改，确保数据的一致性和有效性。通常，<code>set</code>函数会对输入值进行验证，防止无效数据被赋值给成员变量。</p>
<h4 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a><code>get</code>函数</h4><p><code>get</code>函数（或getter函数）用于获取类的私有数据成员的值。通过使用<code>get</code>函数，你可以访问类的私有数据成员，而无需直接暴露这些成员变量。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个简单的例子，展示了如何在C++类中使用<code>set</code>和<code>get</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Setter for name</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string &amp;n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter for name</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter for age</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) &#123; <span class="comment">// simple validation</span></span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter for age</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">setName</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    person.<span class="built_in">setAge</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; person.<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; person.<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>Person</code>类有两个私有成员变量：<code>name</code>和<code>age</code>。</li>
<li><code>setName</code>函数用于设置<code>name</code>的值。</li>
<li><code>getName</code>函数用于获取<code>name</code>的值。</li>
<li><code>setAge</code>函数用于设置<code>age</code>的值，并对输入值进行简单验证（确保年龄不为负数）。</li>
<li><code>getAge</code>函数用于获取<code>age</code>的值。</li>
</ul>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>使用<code>set</code>和<code>get</code>函数的好处包括：</p>
<ol>
<li><strong>封装性</strong>：通过将数据成员设置为私有，并使用公共的<code>set</code>和<code>get</code>函数访问它们，可以更好地封装数据，防止外部直接访问和修改数据。</li>
<li><strong>数据验证</strong>：可以在<code>set</code>函数中添加数据验证逻辑，确保数据的有效性。</li>
<li><strong>维护性</strong>：如果需要更改数据成员的内部表示，只需修改<code>set</code>和<code>get</code>函数的实现，而不需要修改使用这些函数的代码。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>set</code>和<code>get</code>函数是C++类中的常见方法，用于受控地访问和修改类的私有数据成员。它们通过提供数据封装和验证机制，提高了代码的健壮性和可维护性。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><h4 id="友元声明和作用域"><a href="#友元声明和作用域" class="headerlink" title="友元声明和作用域"></a>友元声明和作用域</h4><p><img src="https://gitee.com/salianbooth/picture/raw/master/202407181759430.png" alt="Clip_2024-07-18_17-59-07"></p>
<h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><p><img src="https://gitee.com/salianbooth/picture/raw/master/202407181808544.png" alt="Clip_2024-07-18_18-08-50"></p>
<h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h3><p>成员初始值列表只有一个唯一的入口，就是类名本身。</p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202407181848600.png" alt="Clip_2024-07-18_18-48-28"></p>
<h3 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a>7.5.3 默认构造函数的作用</h3><p>对象被默认初始化会自动执行默认的构造函数</p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202407181849206.png" alt="Clip_2024-07-18_18-49-48"></p>
<h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h3><p>​	<strong>聚合类</strong>使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。</p>
<ul>
<li>所有成员都是public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，没有virtual函数</li>
</ul>
<h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h3><p>常量表达式（constant expressions）是在编译时就能够被计算出来的表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> max_size = <span class="number">100</span>; <span class="comment">// 常量表达式声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[max_size]; <span class="comment">// 使用常量表达式来定义数组大小</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>max_size</code>是一个常量表达式，它的值在编译时就被确定了。它被用于定义数组的大小、枚举类中的成员、以及模板函数的参数中。</p>
<h4 id="constexper"><a href="#constexper" class="headerlink" title="**constexper **"></a>**constexper **</h4><p>它用于声明可以在编译时求值的常量表达式函数或变量。<code>constexpr</code> 函数的返回值在编译时是确定的，这使得编译器可以在编译过程中进行更多的优化，从而提高程序的性能。</p>
<p><code>constexpr</code> 变量必须在声明时初始化，并且初始化表达式必须是常量表达式。</p>
<h5 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a><code>constexpr</code> 函数</h5><p><code>constexpr</code> 函数可以用于定义在编译时计算结果的函数。所有在 <code>constexpr</code> 函数中的代码必须是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 在编译时求值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>数据成员都是字面值类型</strong>：<ul>
<li>类的所有数据成员必须是字面值类型。字面值类型是可以在编译时确定的类型，如整数、浮点数、指针等。</li>
</ul>
</li>
<li><strong>类必须至少含有一个 <code>constexpr</code> 构造函数</strong>：<ul>
<li>类需要至少有一个 <code>constexpr</code> 构造函数，这意味着该构造函数可以在编译时常量表达式中使用。</li>
</ul>
</li>
<li><strong>类的数据成员初始化</strong>：<ul>
<li>如果一个数据成员含有类内初始值，则初始值必须是一条常量表达式，或者该成员属于某种类类型，则初始值必须使用成员自己的 <code>constexpr</code> 构造函数。</li>
</ul>
</li>
<li><strong>析构函数的默认定义</strong>：<ul>
<li>类必须使用析构函数的默认定义，该成员负责销毁段类的对象。这意味着析构函数应该是编译器生成的默认析构函数，而不是自定义的析构函数。</li>
</ul>
</li>
</ol>
<p>这些要求确保了类在编译时可以完全确定，从而使类的对象可以在编译时创建和使用。</p>
<h1 id="Chapter-08-I-O库"><a href="#Chapter-08-I-O库" class="headerlink" title="Chapter 08 I&#x2F;O库"></a>Chapter 08 I&#x2F;O库</h1><h2 id="8-1-1条件状态（condition-state）"><a href="#8-1-1条件状态（condition-state）" class="headerlink" title="8.1 .1条件状态（condition state）"></a>8.1 .1条件状态（condition state）</h2><p>在C++的输入&#x2F;输出（I&#x2F;O）库中，条件状态（condition state）是指流对象的当前状态，表示流在操作过程中是否遇到了错误或特殊情况。这些状态标志有助于程序员了解I&#x2F;O操作是否成功，并采取适当的措施进行处理。C++标准库通过<code>std::ios</code>类提供了一组流状态标志，用于表示和检查这些条件状态。</p>
<h3 id="流状态标志"><a href="#流状态标志" class="headerlink" title="流状态标志"></a>流状态标志</h3><p>以下是主要的流状态标志及其含义：</p>
<ol>
<li><p><strong>eofbit</strong>（end-of-file bit）</p>
<ul>
<li>表示流到达文件末尾。</li>
<li>当读取操作尝试从流中读取数据，但已到达文件末尾时设置。</li>
<li>可以使用<code>eof()</code>成员函数检查。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reached end of file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>failbit</strong>（fail bit）</p>
<ul>
<li>表示一次非致命性格式错误或其他输入&#x2F;输出操作失败。</li>
<li>通常在尝试读取类型不匹配的数据时设置。</li>
<li>可以使用<code>fail()</code>成员函数检查。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Input operation failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>badbit</strong>（bad bit）</p>
<ul>
<li>表示流出现不可恢复的错误，如物理读写错误。</li>
<li>一旦设置，流通常无法再继续使用。</li>
<li>可以使用<code>bad()</code>成员函数检查。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Irrecoverable stream error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>goodbit</strong>（good bit）</p>
<ul>
<li>表示流状态正常，没有错误。</li>
<li>可以使用<code>good()</code>成员函数检查。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stream is in good state.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="检查和重置流状态"><a href="#检查和重置流状态" class="headerlink" title="检查和重置流状态"></a>检查和重置流状态</h3><ul>
<li><p><strong>检查流状态</strong>：可以通过流对象的成员函数来检查不同的流状态。</p>
</li>
<li><p>清除状态标志</p>
<p>：可以使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure>

<p>成员函数重置流的状态标志，使其回到有效状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">clear</span>(); <span class="comment">// 清除所有错误标志</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-1-2-关联输入和输出"><a href="#8-1-2-关联输入和输出" class="headerlink" title="8.1.2 关联输入和输出"></a>8.1.2 关联输入和输出</h2><h3 id="ie函数的作用"><a href="#ie函数的作用" class="headerlink" title="ie函数的作用"></a><code>ie</code>函数的作用</h3><p>在C++标准库中，<code>tie</code>函数用于将一个<code>istream</code>对象与一个<code>ostream</code>对象关联起来。这样做的目的是在每次读取输入流（如<code>cin</code>）时，自动刷新（flush）输出流（如<code>cout</code>），确保输出流中的所有数据都已经输出到终端或文件。</p>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>图片中的代码展示了如何使用<code>tie</code>函数来关联和解除关联流对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.tie(&amp;cout);  // 将cin与cout关联起来</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码将<code>cin</code>与<code>cout</code>关联起来。标准库默认情况下已经将<code>cin</code>和<code>cout</code>关联在一起，因此这行代码只是展示了如何进行这种关联。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream *old_tie = cin.tie(nullptr);  // 解除cin与其他流的关联</span><br></pre></td></tr></table></figure>

<ul>
<li>这行代码将<code>cin</code>与所有输出流解除关联。函数<code>cin.tie(nullptr)</code>返回的是之前<code>cin</code>关联的输出流指针，这里存储在<code>old_tie</code>中，以便稍后恢复这种关联。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.tie(&amp;cerr);  // 将cin与cerr关联起来</span><br></pre></td></tr></table></figure>

<ul>
<li>这行代码将<code>cin</code>与<code>cerr</code>（标准错误输出流）关联起来。这意味着每次从<code>cin</code>读取输入时，都会刷新<code>cerr</code>而不是<code>cout</code>。这种做法一般不推荐，因为标准输入<code>cin</code>通常应该与标准输出<code>cout</code>关联。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.tie(old_tie);  // 恢复cin和cout之间的正常关联</span><br></pre></td></tr></table></figure>

<ul>
<li>这行代码恢复了之前<code>cin</code>和<code>cout</code>之间的关联，将<code>cin</code>重新与之前保存的流（即<code>cout</code>）关联。</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在这段代码中，通过将一个给定的流关联到一个新的输出流，我们使用新的指针传递给<code>tie</code>函数。为了彻底解除流的关联，我们传递了一个空指针（<code>nullptr</code>）。每个流同时最多只能关联到一个输出流，但多个流可以同时关联到同一个输出流。</p>
<h4 id="关联流的用途"><a href="#关联流的用途" class="headerlink" title="关联流的用途"></a>关联流的用途</h4><ul>
<li>主要用于确保输入流读取之前，输出流中的数据已被刷新。</li>
<li>常见用例是将<code>cin</code>和<code>cout</code>关联在一起，以确保用户在输入数据之前看到所有的提示信息。</li>
</ul>
<p>通过这段代码和解释，你可以更好地理解如何在C++中管理输入输出流的关联，以及为什么这种关联有助于确保数据的正确读写顺序。</p>
<h2 id="8-2-文件的输入和输出"><a href="#8-2-文件的输入和输出" class="headerlink" title="8.2 文件的输入和输出"></a>8.2 文件的输入和输出</h2><p>在C++中，处理文件输入和输出的主要类是<code>ifstream</code>（输入文件流）和<code>ofstream</code>（输出文件流），它们分别继承自<code>istream</code>和<code>ostream</code>。</p>
<h4 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h4><p>为了从文件中读取数据或向文件中写入数据，首先需要创建一个<code>ifstream</code>或<code>ofstream</code>对象并打开文件。</p>
<p><strong>打开文件</strong></p>
<ul>
<li><p>ifstream和ofstream对象在创建时可以直接打开文件，方法是将文件名作为构造函数的参数传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream inputFile(&quot;input.txt&quot;);  // 打开用于读的文件</span><br><span class="line">std::ofstream outputFile(&quot;output.txt&quot;);  // 打开用于写的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用open成员函数打开文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream inputFile;</span><br><span class="line">inputFile.open(&quot;input.txt&quot;);</span><br><span class="line"></span><br><span class="line">std::ofstream outputFile;</span><br><span class="line">outputFile.open(&quot;output.txt&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>检查文件是否打开成功</strong></p>
<ul>
<li><p>文件流对象可以转换为一个布尔值，以检查文件是否成功打开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!inputFile) &#123;</span><br><span class="line">    std::cerr &lt;&lt; &quot;Failed to open input file&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">if (!outputFile) &#123;</span><br><span class="line">    std::cerr &lt;&lt; &quot;Failed to open output file&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-2-2-文件输入和输出"><a href="#8-2-2-文件输入和输出" class="headerlink" title="8.2.2 文件输入和输出"></a>8.2.2 文件输入和输出</h4><p><strong>读取文件</strong></p>
<ul>
<li><p>可以使用标准输入流操作符&gt;&gt;或getline函数从文件中读取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string line;</span><br><span class="line">while (std::getline(inputFile, line)) &#123;</span><br><span class="line">    std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>写入文件</strong></p>
<ul>
<li><p>可以使用标准输出流操作符&lt;&lt;向文件中写入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile &lt;&lt; &quot;Hello, file!&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>文件流的关闭</strong></p>
<ul>
<li><p>文件流在析构时会自动关闭，但也可以显式地调用close函数关闭文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputFile.close();</span><br><span class="line">outputFile.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-2-3-文件模式"><a href="#8-2-3-文件模式" class="headerlink" title="8.2.3 文件模式"></a>8.2.3 文件模式</h4><p>文件流可以用不同的模式打开，以控制文件的读写行为。常用的文件模式如下：</p>
<ul>
<li><code>std::ios::in</code>：以读模式打开文件（<code>ifstream</code>默认）。</li>
<li><code>std::ios::out</code>：以写模式打开文件（<code>ofstream</code>默认）。</li>
<li><code>std::ios::app</code>：以追加模式打开文件，写入的数据会追加到文件末尾。</li>
<li><code>std::ios::ate</code>：打开文件并定位到文件末尾。</li>
<li><code>std::ios::trunc</code>：如果文件已存在，截断文件长度为0。</li>
<li><code>std::ios::binary</code>：以二进制模式打开文件。</li>
</ul>
<p>这些模式可以组合使用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::ofstream outputFile(&quot;output.txt&quot;, std::ios::out | std::ios::app);</span><br></pre></td></tr></table></figure>

<h4 id="8-2-4-随机访问文件"><a href="#8-2-4-随机访问文件" class="headerlink" title="8.2.4 随机访问文件"></a>8.2.4 随机访问文件</h4><p>C++文件流提供了一些函数，可以在文件中随机访问数据：</p>
<ul>
<li><code>seekg</code>：在输入文件流中定位到指定位置。</li>
<li><code>seekp</code>：在输出文件流中定位到指定位置。</li>
<li><code>tellg</code>：返回输入文件流中的当前位置。</li>
<li><code>tellp</code>：返回输出文件流中的当前位置。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputFile.seekg(0, std::ios::beg);  // 定位到文件开始</span><br><span class="line">std::streampos pos = inputFile.tellg();  // 获取当前位置</span><br><span class="line">inputFile.seekg(pos);  // 定位到pos</span><br></pre></td></tr></table></figure>

<p>通过这些函数，可以在文件中任意位置进行读写操作。</p>
<h1 id="Chapter-9-顺序容器"><a href="#Chapter-9-顺序容器" class="headerlink" title="Chapter 9 顺序容器"></a>Chapter 9 顺序容器</h1><h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><p><strong>Tips：使用vector是最好的选择，除非有更好的理由选择其他</strong></p>
<h3 id="选择容器的基本原则"><a href="#选择容器的基本原则" class="headerlink" title="选择容器的基本原则"></a>选择容器的基本原则</h3><ol>
<li>**默认选择<code>vector</code>**：<br>除非你有很好的理由选择其他容器，否则应该使用<code>vector</code>。</li>
<li><strong>元素数量多且空间重要时</strong>：<br>如果你的程序有很多小的元素，并且空间的额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code>。</li>
<li><strong>随机访问元素时</strong>：<br>如果程序要求随机访问元素，应使用<code>vector</code>或<code>deque</code>。</li>
<li><strong>中间插入或删除元素时</strong>：<br>如果程序要求在容器的中间插入或删除元素，应使用<code>list</code>或<code>forward_list</code>。</li>
<li><strong>头尾插入或删除但不在中间操作时</strong>：<br>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用<code>deque</code>。</li>
<li><strong>读输入时才需要插入并随机访问时</strong>：<br>如果程序只有在读取输入时才需要在容器中间插入元素，随后需要随机访问元素，则：<ul>
<li>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向<code>vector</code>添加数据，然后再调用标准库的<code>sort</code>函数来重新排序容器中的元素，从而避免在中间位置添加元素。</li>
<li>如果必须在中间位置插入元素，考虑在输入阶段使用<code>list</code>，一旦输入完成，将<code>list</code>中的内容拷贝到一个<code>vector</code>中。</li>
</ul>
</li>
</ol>
<h2 id="9-2-容器库概述"><a href="#9-2-容器库概述" class="headerlink" title="9.2 容器库概述"></a>9.2 容器库概述</h2><h4 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h4><p>顺序容器提供了迭代器，用于遍历和操作容器中的元素。常用的迭代器类型包括：</p>
<ul>
<li>**<code>iterator</code>**：读写访问。</li>
<li>**<code>const_iterator</code>**：只读访问。</li>
<li>**<code>reverse_iterator</code>**：反向读写访问。</li>
<li>**<code>const_reverse_iterator</code>**：反向只读访问。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-2-容器的大小操作"><a href="#9-2-2-容器的大小操作" class="headerlink" title="9.2.2 容器的大小操作"></a>9.2.2 容器的大小操作</h4><p>顺序容器提供了多种方法来获取和修改容器的大小：</p>
<ul>
<li>**<code>size</code>**：返回容器中元素的数量。</li>
<li>**<code>empty</code>**：检查容器是否为空。</li>
<li>**<code>max_size</code>**：返回容器能够容纳的最大元素数量。</li>
<li>**<code>resize</code>**：改变容器的大小。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is empty: &quot;</span> &lt;&lt; vec.<span class="built_in">empty</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Resized vector size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-3-添加元素"><a href="#9-2-3-添加元素" class="headerlink" title="9.2.3 添加元素"></a>9.2.3 添加元素</h4><p>顺序容器提供了多种方法来添加元素：</p>
<ul>
<li>**<code>push_back</code>**：在容器末尾添加元素。</li>
<li>**<code>insert</code>**：在指定位置插入元素。</li>
<li>**<code>emplace_back</code>**：在容器末尾原地构造元素。</li>
<li>**<code>emplace</code>**：在指定位置原地构造元素。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-4-删除元素"><a href="#9-2-4-删除元素" class="headerlink" title="9.2.4 删除元素"></a>9.2.4 删除元素</h4><p>顺序容器提供了多种方法来删除元素：</p>
<ul>
<li>**<code>pop_back</code>**：删除容器末尾的元素。</li>
<li>**<code>erase</code>**：删除指定位置的元素或范围内的元素。</li>
<li>**<code>clear</code>**：删除容器中的所有元素。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size after clear: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-5-访问元素"><a href="#9-2-5-访问元素" class="headerlink" title="9.2.5 访问元素"></a>9.2.5 访问元素</h4><p>顺序容器提供了多种方法来访问元素：</p>
<ul>
<li>**<code>operator[]</code>**：随机访问指定位置的元素。</li>
<li>**<code>at</code>**：随机访问指定位置的元素，并进行边界检查。</li>
<li>**<code>front</code>**：访问第一个元素。</li>
<li>**<code>back</code>**：访问最后一个元素。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; vec.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 3: &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><h3 id="9-3-1-添加元素"><a href="#9-3-1-添加元素" class="headerlink" title="9.3.1 添加元素"></a>9.3.1 添加元素</h3><h4 id="emplace-系列函数的基本概念"><a href="#emplace-系列函数的基本概念" class="headerlink" title="emplace 系列函数的基本概念"></a><code>emplace</code> 系列函数的基本概念</h4><p><code>emplace</code> 系列函数将传入的参数直接传递给对象的构造函数，以在容器的特定位置构造对象。这种方式能够在避免临时对象的情况下高效地将新元素添加到容器中。</p>
<h4 id="常用的-emplace-系列函数"><a href="#常用的-emplace-系列函数" class="headerlink" title="常用的 emplace 系列函数"></a>常用的 <code>emplace</code> 系列函数</h4><ol>
<li><p>**<code>emplace_back</code>**：</p>
<ul>
<li>在容器末尾直接构造对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">42</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 直接在末尾构造一个 std::pair&lt;int, std::string&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace</code>**：</p>
<ul>
<li>在容器的指定位置直接构造对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::string&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> it = lst.<span class="built_in">emplace</span>(lst.<span class="built_in">begin</span>(), <span class="string">&quot;world&quot;</span>); <span class="comment">// 在开头直接构造一个 std::string</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="emplace-系列函数的优势"><a href="#emplace-系列函数的优势" class="headerlink" title="emplace 系列函数的优势"></a><code>emplace</code> 系列函数的优势</h4><ul>
<li><strong>避免不必要的拷贝或移动</strong>：<code>emplace</code> 系列函数直接在容器内部构造对象，省去了拷贝或移动对象所带来的开销。</li>
<li><strong>简化代码</strong>：使用 <code>emplace</code> 系列函数可以省略创建临时对象的步骤，代码更加简洁。</li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>假设有一个自定义类 <code>Person</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>emplace_back</code> 直接在容器中构造 <code>Person</code> 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Person&gt; people;</span><br><span class="line">people.<span class="built_in">emplace_back</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>); <span class="comment">// 直接在末尾构造一个 Person 对象</span></span><br></pre></td></tr></table></figure>

<p>与 <code>push_back</code> 对比：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Person&gt; people;</span><br><span class="line">people.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)); <span class="comment">// 先创建临时对象，再拷贝到容器中</span></span><br></pre></td></tr></table></figure>

<p><strong>总之</strong> emplace的主要优势在于 <strong>构造类对象</strong></p>
<h3 id="9-3-6-容器操作会使迭代器失效"><a href="#9-3-6-容器操作会使迭代器失效" class="headerlink" title="9.3.6 容器操作会使迭代器失效"></a>9.3.6 容器操作会使迭代器失效</h3><h4 id="容器操作及其对迭代器失效的影响"><a href="#容器操作及其对迭代器失效的影响" class="headerlink" title="容器操作及其对迭代器失效的影响"></a>容器操作及其对迭代器失效的影响</h4><ol>
<li>**<code>vector</code> 和 <code>string</code>**：<ul>
<li><strong>增加元素</strong>：当 <code>vector</code> 或 <code>string</code> 需要重新分配内存时，所有的迭代器、引用和指针都会失效。</li>
<li><strong>删除元素</strong>：从 <code>vector</code> 或 <code>string</code> 中删除元素时，指向删除点及其后的迭代器、引用和指针都会失效。</li>
</ul>
</li>
<li>**<code>deque</code>**：<ul>
<li><strong>增加元素</strong>：在头部或尾部增加元素时，所有迭代器都会失效。</li>
<li><strong>删除元素</strong>：在头部或尾部删除元素时，所有迭代器都会失效。</li>
<li><strong>中间插入或删除</strong>：只会使指向操作点及其后的迭代器失效。</li>
</ul>
</li>
<li>**<code>list</code> 和 <code>forward_list</code>**：<ul>
<li>由于 <code>list</code> 是双向链表，<code>forward_list</code> 是单向链表，它们的节点在内存中不连续，增加或删除元素时，指向其他节点的迭代器不会失效，除非是指向被删除节点的迭代器。</li>
</ul>
</li>
<li>**<code>associative containers</code> (如 <code>set</code>, <code>map</code> 等)**：<ul>
<li>增加或删除元素时，指向其他元素的迭代器不会失效，除非是指向被删除元素的迭代器。</li>
</ul>
</li>
<li>**<code>unordered containers</code>**：<ul>
<li>插入元素可能会导致容器重新哈希，从而使所有迭代器失效。</li>
<li>删除元素时，指向其他元素的迭代器不会失效，除非是指向被删除元素的迭代器。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();it &lt; v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;========&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>((*it) == <span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;starting pushing &quot;</span> &lt;&lt; endl;</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">========</span><br><span class="line">v capacity:<span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">starting pushing   <span class="comment">//在这里，我们push_back了一个新元素进去</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span>  <span class="comment">//这个时候，v的容量变成了原来的2倍，也就是10</span></span><br><span class="line"><span class="number">-1434582704</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">606</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span>  <span class="comment">//旧的迭代器结束</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span>    <span class="comment">//中间多了3个其他的数值，来区分开来新旧迭代器</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">-1174562285</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">134280406</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span>   <span class="comment">//新的迭代器</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">starting pushing</span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">========</span><br><span class="line">v capacity:<span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="9-4-vector是如何增长的"><a href="#9-4-vector是如何增长的" class="headerlink" title="9.4 vector是如何增长的"></a>9.4 vector是如何增长的</h2><h3 id="1-检查是否需要扩容"><a href="#1-检查是否需要扩容" class="headerlink" title="1. 检查是否需要扩容"></a>1. <strong>检查是否需要扩容</strong></h3><p>当我们向<code>vector</code>中添加元素时，首先会检查当前的大小是否已经达到了容量。如果没有，则元素可以直接添加，无需分配新的内存。</p>
<h3 id="2-确定新的容量"><a href="#2-确定新的容量" class="headerlink" title="2. 确定新的容量"></a>2. <strong>确定新的容量</strong></h3><p>如果<code>size</code>已经等于<code>capacity</code>，则<code>vector</code>需要增加容量。新的容量通常是现有容量的两倍，但这并非标准规定的行为，而是一种常见的实现策略。这个策略的优点是减少了频繁分配内存的开销。</p>
<h3 id="3-分配新内存并复制旧数据"><a href="#3-分配新内存并复制旧数据" class="headerlink" title="3. 分配新内存并复制旧数据"></a>3. <strong>分配新内存并复制旧数据</strong></h3><p><code>vector</code>会分配一块新的内存空间，其大小等于新的容量。然后，它会将旧内存中的元素逐个复制到新内存中。这是因为标准要求元素要在与它们被销毁的地方不同的内存位置构造。复制完成后，旧的内存会被释放。</p>
<h3 id="4-调整内部指针"><a href="#4-调整内部指针" class="headerlink" title="4. 调整内部指针"></a>4. <strong>调整内部指针</strong></h3><p>新内存中的元素构造完成后，<code>vector</code>的内部指针和相关数据成员会更新，以反映新的容量和内存地址。</p>
<h3 id="5-更新容量和大小"><a href="#5-更新容量和大小" class="headerlink" title="5. 更新容量和大小"></a>5. <strong>更新容量和大小</strong></h3><p>扩容完成后，<code>vector</code>的<code>capacity</code>会被更新为新的容量，而<code>size</code>会增加到包含新元素的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prev_capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prev_capacity != vec.<span class="built_in">capacity</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;changed -&gt;&quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">            prev_capacity = vec.<span class="built_in">capacity</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5-String的额外操作"><a href="#9-5-String的额外操作" class="headerlink" title="9.5 String的额外操作"></a>9.5 String的额外操作</h2><h3 id="1-修改操作"><a href="#1-修改操作" class="headerlink" title="1. 修改操作"></a>1. <strong>修改操作</strong></h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a><strong>插入操作</strong></h4><ul>
<li><strong>插入字符或字符串</strong>：可以使用<code>insert</code>方法在指定位置插入字符或字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot; World&quot;</span>); <span class="comment">// str变为 &quot;Hello World&quot;</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;X&#x27;</span>);   <span class="comment">// str变为 &quot;XHello World&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h4><ul>
<li><strong>删除子串</strong>：可以使用<code>erase</code>方法从指定位置开始删除指定长度的字符。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">6</span>); <span class="comment">// str变为 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a><strong>替换操作</strong></h4><ul>
<li><strong>替换子串</strong>：可以使用<code>replace</code>方法将指定位置的子串替换为另一个字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="string">&quot;C++&quot;</span>); <span class="comment">// str变为 &quot;Hello C++&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-搜索操作"><a href="#2-搜索操作" class="headerlink" title="2. 搜索操作"></a>2. <strong>搜索操作</strong></h3><h4 id="查找字符或子串"><a href="#查找字符或子串" class="headerlink" title="查找字符或子串"></a><strong>查找字符或子串</strong></h4><ul>
<li><strong>查找字符</strong>：可以使用<code>find</code>方法查找字符或字符串的第一次出现位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&#x27;W&#x27;</span>);   <span class="comment">// pos为6</span></span><br><span class="line">pos = str.<span class="built_in">find</span>(<span class="string">&quot;World&quot;</span>);      <span class="comment">// pos为6</span></span><br><span class="line">pos = str.<span class="built_in">find</span>(<span class="string">&#x27;X&#x27;</span>);          <span class="comment">// pos为std::string::npos（未找到）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>从末尾查找</strong>：可以使用<code>rfind</code>方法从字符串末尾开始查找字符或子串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World World&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">rfind</span>(<span class="string">&quot;World&quot;</span>); <span class="comment">// pos为12</span></span><br></pre></td></tr></table></figure>

<h3 id="3-比较操作"><a href="#3-比较操作" class="headerlink" title="3. 比较操作"></a>3. <strong>比较操作</strong></h3><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a><strong>字符串比较</strong></h4><ul>
<li><strong>比较字符串</strong>：可以使用<code>compare</code>方法比较两个字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = str<span class="number">1.</span><span class="built_in">compare</span>(str2); <span class="comment">// result &lt; 0, 因为 &quot;Hello&quot; &lt; &quot;World&quot;</span></span><br><span class="line">result = str<span class="number">1.</span><span class="built_in">compare</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// result == 0, 因为字符串相同</span></span><br></pre></td></tr></table></figure>

<h3 id="4-子串操作"><a href="#4-子串操作" class="headerlink" title="4. 子串操作"></a>4. <strong>子串操作</strong></h3><h4 id="获取子串"><a href="#获取子串" class="headerlink" title="获取子串"></a><strong>获取子串</strong></h4><ul>
<li><strong>提取子串</strong>：可以使用<code>substr</code>方法从指定位置开始提取一定长度的子串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">std::string sub = str.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">5</span>); <span class="comment">// sub为 &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-大小写转换"><a href="#5-大小写转换" class="headerlink" title="5. 大小写转换"></a>5. <strong>大小写转换</strong></h3><h4 id="转换为小写或大写"><a href="#转换为小写或大写" class="headerlink" title="转换为小写或大写"></a><strong>转换为小写或大写</strong></h4><p>C++标准库没有内置的方法来直接将<code>string</code>转换为大写或小写，但可以通过使用<code>&lt;cctype&gt;</code>库中的<code>std::tolower</code>和<code>std::toupper</code>函数来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span> <span class="comment">// for std::tolower and std::toupper</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">toLower</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">        result += std::<span class="built_in">tolower</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">toUpper</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">        result += std::<span class="built_in">toupper</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    std::string lower = <span class="built_in">toLower</span>(str); <span class="comment">// lower为 &quot;hello world&quot;</span></span><br><span class="line">    std::string upper = <span class="built_in">toUpper</span>(str); <span class="comment">// upper为 &quot;HELLO WORLD&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-字符串长度"><a href="#6-字符串长度" class="headerlink" title="6. 字符串长度"></a>6. <strong>字符串长度</strong></h3><h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a><strong>获取长度</strong></h4><ul>
<li><strong>长度和容量</strong>：可以使用<code>size</code>或<code>length</code>方法获取字符串的长度，使用<code>capacity</code>方法获取分配的内存大小。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> len = str.<span class="built_in">size</span>();    <span class="comment">// len为11</span></span><br><span class="line"><span class="type">size_t</span> cap = str.<span class="built_in">capacity</span>();<span class="comment">// cap为分配的内存大小</span></span><br></pre></td></tr></table></figure>

<h3 id="7-字符串连接"><a href="#7-字符串连接" class="headerlink" title="7. 字符串连接"></a>7. <strong>字符串连接</strong></h3><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a><strong>拼接字符串</strong></h4><ul>
<li><strong>使用<code>+</code>操作符</strong>：可以使用<code>+</code>操作符连接两个字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">std::string result = str1 + <span class="string">&quot; &quot;</span> + str2; <span class="comment">// result为 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用<code>append</code>方法</strong>：可以使用<code>append</code>方法将一个字符串追加到另一个字符串的末尾。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot; World&quot;</span>); <span class="comment">// str变为 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-输入输出操作"><a href="#8-输入输出操作" class="headerlink" title="8. 输入输出操作"></a>8. <strong>输入输出操作</strong></h3><h4 id="从标准输入读取"><a href="#从标准输入读取" class="headerlink" title="从标准输入读取"></a><strong>从标准输入读取</strong></h4><ul>
<li>**使用<code>getline</code>**：可以使用<code>getline</code>从标准输入读取一行。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">std::<span class="built_in">getline</span>(std::cin, str);</span><br></pre></td></tr></table></figure>

<h4 id="输出到标准输出"><a href="#输出到标准输出" class="headerlink" title="输出到标准输出"></a><strong>输出到标准输出</strong></h4><ul>
<li><strong>使用<code>&lt;&lt;</code>操作符</strong>：可以使用<code>&lt;&lt;</code>操作符将字符串输出到标准输出。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h1 id="Chapter10-泛型算法"><a href="#Chapter10-泛型算法" class="headerlink" title="Chapter10 泛型算法"></a>Chapter10 泛型算法</h1><h2 id="10-1-泛型算法概述"><a href="#10-1-泛型算法概述" class="headerlink" title="10.1 泛型算法概述"></a>10.1 泛型算法概述</h2><p>泛型算法是独立于数据类型的算法，它们通过模板机制实现，主要用于标准容器。C++标准库提供了一组丰富的泛型算法，可以进行排序、搜索、变换等操作。</p>
<h3 id="常用泛型算法"><a href="#常用泛型算法" class="headerlink" title="常用泛型算法"></a>常用泛型算法</h3><ol>
<li><strong>排序算法</strong><ul>
<li><code>sort</code>：对范围内的元素进行排序。</li>
<li><code>stable_sort</code>：保持相等元素的相对顺序的排序。</li>
<li><code>partial_sort</code>：部分排序，仅使得部分元素有序。</li>
</ul>
</li>
<li><strong>查找算法</strong><ul>
<li><code>find</code>：在范围内查找等于给定值的第一个元素。</li>
<li><code>find_if</code>：根据谓词在范围内查找第一个满足条件的元素。</li>
<li><code>binary_search</code>：二分查找，要求范围内元素有序。</li>
</ul>
</li>
<li><strong>修改序列的算法</strong><ul>
<li><code>copy</code>：将一个范围内的元素复制到另一个范围。</li>
<li><code>copy_if</code>：将满足条件的元素复制到另一个范围。</li>
<li><code>replace</code>：将范围内所有等于某值的元素替换为另一个值。</li>
</ul>
</li>
<li><strong>删除算法</strong><ul>
<li><code>remove</code>：移除所有等于某值的元素（不改变容器大小）。</li>
<li><code>remove_if</code>：移除所有满足条件的元素（不改变容器大小）。</li>
</ul>
</li>
<li><strong>变换算法</strong><ul>
<li><code>transform</code>：对范围内的元素应用给定操作，并将结果存储到另一个范围。</li>
<li><code>accumulate</code>：计算范围内元素的累积和。</li>
</ul>
</li>
</ol>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是泛型算法的关键组件，STL提供了不同类型的迭代器：</p>
<ul>
<li><strong>输入迭代器</strong>：只读，单遍历。</li>
<li><strong>输出迭代器</strong>：只写，单遍历。</li>
<li><strong>前向迭代器</strong>：可读可写，多遍历。</li>
<li><strong>双向迭代器</strong>：前向迭代器的扩展，可向前和向后遍历。</li>
<li><strong>随机访问迭代器</strong>：支持常量时间的随机访问。</li>
</ul>
<h2 id="绑定器的作用"><a href="#绑定器的作用" class="headerlink" title="绑定器的作用"></a>绑定器的作用</h2><p>绑定器可以将函数的一部分参数预先绑定，然后生成一个新的可调用对象，这个对象可以在需要时提供其余的参数。这在需要部分应用函数时特别有用，例如与泛型算法结合使用。</p>
<h3 id="std-bind-的使用"><a href="#std-bind-的使用" class="headerlink" title="std::bind 的使用"></a><code>std::bind</code> 的使用</h3><p><code>std::bind</code> 函数在头文件 <code>&lt;functional&gt;</code> 中定义，其用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto bound_function = std::bind(function, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>function</code>：要绑定的函数，可以是普通函数、成员函数、函数对象、lambda表达式等。</li>
<li><code>arg1, arg2, ...</code>：要绑定的参数，可以是具体值、占位符 <code>_1, _2, ...</code>（表示将在调用时提供的参数）。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下示例展示了如何使用 <code>std::bind</code> 绑定参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void print_sum(int a, int b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用std::bind绑定第一个参数</span><br><span class="line">    auto print_sum_with_10 = std::bind(print_sum, 10, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    // 调用绑定后的函数，只需提供剩余的一个参数</span><br><span class="line">    print_sum_with_10(5);  // 输出: Sum: 15</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定成员函数"><a href="#绑定成员函数" class="headerlink" title="绑定成员函数"></a>绑定成员函数</h3><p>绑定成员函数需要使用对象实例或对象指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class Printer &#123;</span><br><span class="line">public:</span><br><span class="line">    void print(int a, int b) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Printer printer;</span><br><span class="line"></span><br><span class="line">    // 使用std::bind绑定成员函数</span><br><span class="line">    auto bound_print = std::bind(&amp;Printer::print, &amp;printer, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line"></span><br><span class="line">    // 调用绑定后的函数</span><br><span class="line">    bound_print(10, 5);  // 输出: Sum: 15</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结合泛型算法使用"><a href="#结合泛型算法使用" class="headerlink" title="结合泛型算法使用"></a>结合泛型算法使用</h3><p><code>std::bind</code> 常与泛型算法结合使用，使得算法可以接受自定义的函数行为。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">bool check_size(const std::string&amp; s, std::string::size_type sz) &#123;</span><br><span class="line">    return s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; words = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;date&quot;, &quot;elderberry&quot;&#125;;</span><br><span class="line">    std::string::size_type sz = 6;</span><br><span class="line"></span><br><span class="line">    // 使用std::bind将参数绑定到函数</span><br><span class="line">    auto check = std::bind(check_size, std::placeholders::_1, sz);</span><br><span class="line"></span><br><span class="line">    // 使用find_if和绑定的函数</span><br><span class="line">    auto it = std::find_if(words.begin(), words.end(), check);</span><br><span class="line">    if (it != words.end()) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;First word with size &gt;= &quot; &lt;&lt; sz &lt;&lt; &quot; is &quot; &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;No word found with size &gt;= &quot; &lt;&lt; sz &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>std::bind</code> 是一个强大的工具，用于创建部分应用函数和延迟调用。它通过绑定函数的部分参数，生成一个新的可调用对象，使得代码更加简洁和灵活。在泛型编程中，<code>std::bind</code> 常用于将自定义操作传递给算法，从而实现复杂的功能。</p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><ol>
<li><p><strong>迭代器类别</strong>：</p>
<ul>
<li>输入迭代器（Input Iterator）</li>
<li>输出迭代器（Output Iterator）</li>
<li>前向迭代器（Forward Iterator）</li>
<li>双向迭代器（Bidirectional Iterator）</li>
<li>随机访问迭代器（Random Access Iterator）</li>
</ul>
<p>每种类别迭代器具有不同的功能和限制，例如随机访问迭代器支持跳跃访问和算术操作，而输入迭代器只支持单向遍历和读取等。</p>
</li>
<li><p><strong>算法与迭代器</strong>：<br>C++标准库中的算法（如<code>std::sort</code>, <code>std::find</code>, <code>std::transform</code>等）通常通过迭代器来操作数据。不同类别的迭代器能够配合不同的算法使用，这种灵活性使得算法能够适应各种数据结构和访问方式。</p>
</li>
<li><p><strong>迭代器的自定义</strong>：<br>可以通过定义自己的迭代器类型，来适配自定义的数据结构或者提供特定的遍历行为。自定义迭代器需要实现一组迭代器的接口，例如<code>operator++</code>, <code>operator*</code>等，以便被标准库算法正确使用。</p>
</li>
<li><p><strong>示例代码</strong>：<br>下面是一个简单的示例，展示了使用迭代器和算法来处理容器中的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; vec = &#123;3, 1, 4, 1, 5, 9, 2, 6&#125;;</span><br><span class="line"></span><br><span class="line">    // 使用标准库算法和迭代器进行排序</span><br><span class="line">    std::sort(vec.begin(), vec.end());</span><br><span class="line"></span><br><span class="line">    // 使用for循环和迭代器打印排序后的结果</span><br><span class="line">    for (auto it = vec.begin(); it != vec.end(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::sort</code> 算法使用了双向迭代器，对<code>vec</code>进行排序，然后通过<code>for</code>循环遍历输出排序后的结果。</p>
</li>
</ol>
<h2 id="插入迭代器的使用"><a href="#插入迭代器的使用" class="headerlink" title="插入迭代器的使用"></a>插入迭代器的使用</h2><p>插入迭代器有几个常见的变种，主要包括：</p>
<ol>
<li><p><code>std::insert_iterator</code></p>
<p>：</p>
<ul>
<li>这是最常用的插入迭代器类型。</li>
<li>需要指定容器和插入位置。</li>
</ul>
</li>
</ol>
<h3 id="创建插入迭代器"><a href="#创建插入迭代器" class="headerlink" title="创建插入迭代器"></a>创建插入迭代器</h3><p>使用<code>std::insert_iterator</code>需要包含头文件<code>&lt;iterator&gt;</code>，其构造函数的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::insert_iterator&lt;Container&gt; it(container, position);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器类型。</li>
<li><code>position</code> 是插入位置的迭代器。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用插入迭代器的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::insert_iterator将vec2的内容插入到vec1的末尾</span></span><br><span class="line">    std::<span class="built_in">copy</span>(vec<span class="number">2.</span><span class="built_in">begin</span>(), vec<span class="number">2.</span><span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(vec1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印vec1的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec1 after insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::insert_iterator将vec2的内容插入到vec1的指定位置</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec3 = &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec<span class="number">1.</span><span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 指定插入位置</span></span><br><span class="line">    std::<span class="built_in">copy</span>(vec<span class="number">3.</span><span class="built_in">begin</span>(), vec<span class="number">3.</span><span class="built_in">end</span>(), std::insert_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(vec1, it));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印vec1的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec1 after insertion at position: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析示例代码"><a href="#解析示例代码" class="headerlink" title="解析示例代码"></a>解析示例代码</h3><ol>
<li><p>**<code>std::back_inserter</code>**：一个方便的插入迭代器，用于将元素添加到容器的末尾。它的使用方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">copy</span>(vec<span class="number">2.</span><span class="built_in">begin</span>(), vec<span class="number">2.</span><span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(vec1));</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>std::insert_iterator</code>**：用来指定插入位置的迭代器。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">copy</span>(vec<span class="number">3.</span><span class="built_in">begin</span>(), vec<span class="number">3.</span><span class="built_in">end</span>(), std::insert_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(vec1, it));</span><br></pre></td></tr></table></figure>

<p>其中<code>it</code>是指向插入位置的迭代器。</p>
</li>
</ol>
<h2 id="lamada表达式"><a href="#lamada表达式" class="headerlink" title="lamada表达式"></a>lamada表达式</h2><p>Lambda 表达式是 C++11 引入的一种功能，允许你在代码中定义匿名函数。它们通常用于简化代码，使代码更简洁、更易读。Lambda 表达式的基本语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>capture</code>**：捕获列表，用于捕获上下文中的变量。</li>
<li>**<code>parameters</code>**：参数列表，与普通函数的参数列表类似。</li>
<li>**<code>return_type</code>**：返回类型，可以省略，如果可以从返回的表达式中推断出来。</li>
<li>**<code>body</code>**：函数体，包含要执行的代码。</li>
</ul>
<h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p>捕获列表可以捕获外部作用域中的变量，使它们在 Lambda 表达式内部可用。捕获方式包括：</p>
<ul>
<li><strong>按值捕获</strong>（<code>[=]</code>）：捕获外部变量的值。</li>
<li><strong>按引用捕获</strong>（<code>[&amp;]</code>）：捕获外部变量的引用。</li>
<li><strong>显式捕获</strong>：可以选择性地捕获某些变量，如 <code>[x, &amp;y]</code> 表示按值捕获 <code>x</code>，按引用捕获 <code>y</code>。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>以下是一些使用 Lambda 表达式的示例：</p>
<h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式打印每个元素</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-带捕获的-Lambda-表达式"><a href="#2-带捕获的-Lambda-表达式" class="headerlink" title="2. 带捕获的 Lambda 表达式"></a>2. 带捕获的 Lambda 表达式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> factor = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> multiply = [factor](<span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factor;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3 * factor = &quot;</span> &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-修改捕获的变量"><a href="#3-修改捕获的变量" class="headerlink" title="3. 修改捕获的变量"></a>3. 修改捕获的变量</h4><p>按值捕获的变量在 Lambda 表达式内部是不可修改的，但可以通过 <code>mutable</code> 关键字允许修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        ++x;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">increment</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside Lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-捕获外部变量的引用"><a href="#4-捕获外部变量的引用" class="headerlink" title="4. 捕获外部变量的引用"></a>4. 捕获外部变量的引用</h4><p>通过引用捕获外部变量，可以在 Lambda 表达式内部修改这些变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [&amp;x]() &#123;</span><br><span class="line">        ++x;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside Lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">increment</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside Lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-复杂示例：排序"><a href="#5-复杂示例：排序" class="headerlink" title="5. 复杂示例：排序"></a>5. 复杂示例：排序</h4><p>使用 Lambda 表达式进行自定义排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式按降序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式的优点"><a href="#Lambda-表达式的优点" class="headerlink" title="Lambda 表达式的优点"></a>Lambda 表达式的优点</h3><ol>
<li><strong>简洁</strong>：可以在需要函数的地方直接定义，无需单独声明和定义。</li>
<li><strong>灵活</strong>：可以捕获外部变量，使得编写处理复杂逻辑的函数变得更容易。</li>
<li><strong>提高代码可读性</strong>：特别是在使用标准库算法时，Lambda 表达式可以使代码更简洁、更易读。</li>
</ol>
<p>Lambda 表达式在 C++11 引入后，已经成为现代 C++ 编程中的重要工具，广泛应用于标准库算法、自定义操作、事件处理等场景中。</p>
<h1 id="Chapter-11-关联容器"><a href="#Chapter-11-关联容器" class="headerlink" title="Chapter 11 关联容器"></a>Chapter 11 关联容器</h1><h2 id="11-1关联容器概述"><a href="#11-1关联容器概述" class="headerlink" title="11.1关联容器概述"></a>11.1关联容器概述</h2><p>关联容器根据键来存储元素，并提供快速的查找、插入和删除操作。不同于顺序容器（如 <code>std::vector</code>、<code>std::list</code>），关联容器是基于树结构实现的，通常使用红黑树。这使得关联容器中的元素总是有序的（按键排序）。</p>
<h4 id="主要关联容器"><a href="#主要关联容器" class="headerlink" title="主要关联容器"></a>主要关联容器</h4><ol>
<li>**<code>std::map</code>**：一个键值对的集合，每个键是唯一的。</li>
<li>**<code>std::multimap</code>**：一个键值对的集合，允许多个相同的键。</li>
<li>**<code>std::set</code>**：一个键的集合，每个键是唯一的。</li>
<li>**<code>std::multiset</code>**：一个键的集合，允许多个相同的键。</li>
</ol>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="1-使用-std-map"><a href="#1-使用-std-map" class="headerlink" title="1. 使用 std::map"></a>1. 使用 <code>std::map</code></h4><p><code>std::map</code> 是一个键值对容器，键是唯一的，按键排序。以下是一个简单的示例，展示如何插入、访问和遍历 <code>std::map</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个map</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; word_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    word_count[<span class="string">&quot;hello&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">    word_count[<span class="string">&quot;world&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    word_count[<span class="string">&quot;hello&quot;</span>]++;  <span class="comment">// 修改元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello: &quot;</span> &lt;&lt; word_count[<span class="string">&quot;hello&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;world: &quot;</span> &lt;&lt; word_count[<span class="string">&quot;world&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : word_count) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-std-set"><a href="#2-使用-std-set" class="headerlink" title="2. 使用 std::set"></a>2. 使用 <code>std::set</code></h4><p><code>std::set</code> 是一个键的集合，键是唯一的，按键排序。以下是一个简单的示例，展示如何插入、访问和遍历 <code>std::set</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 创建一个set</span><br><span class="line">    std::set&lt;int&gt; numbers;</span><br><span class="line"></span><br><span class="line">    // 插入元素</span><br><span class="line">    numbers.insert(1);</span><br><span class="line">    numbers.insert(2);</span><br><span class="line">    numbers.insert(3);</span><br><span class="line">    numbers.insert(1);  // 重复元素，不会插入</span><br><span class="line"></span><br><span class="line">    // 访问元素</span><br><span class="line">    if (numbers.find(2) != numbers.end()) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;2 is in the set&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历set</span><br><span class="line">    for (const auto&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用-std-multimap"><a href="#3-使用-std-multimap" class="headerlink" title="3. 使用 std::multimap"></a>3. 使用 <code>std::multimap</code></h4><p><code>std::multimap</code> 允许多个相同的键。以下是一个示例，展示如何插入、访问和遍历 <code>std::multimap</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个multimap</span></span><br><span class="line">    std::multimap&lt;std::string, <span class="type">int</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    grades.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">85</span>&#125;);</span><br><span class="line">    grades.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">90</span>&#125;);</span><br><span class="line">    grades.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">95</span>&#125;);  <span class="comment">// 允许重复键</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="keyword">auto</span> range = grades.<span class="built_in">equal_range</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历multimap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : grades) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-2-关联容器的操作"><a href="#11-2-关联容器的操作" class="headerlink" title="11.2 关联容器的操作"></a>11.2 关联容器的操作</h2><h3 id="关联容器的常用操作"><a href="#关联容器的常用操作" class="headerlink" title="关联容器的常用操作"></a>关联容器的常用操作</h3><ol>
<li><strong>插入元素</strong>：<code>insert</code> 方法。</li>
<li><strong>访问元素</strong>：<code>operator[]</code>（适用于 <code>std::map</code>），<code>find</code> 方法。</li>
<li><strong>删除元素</strong>：<code>erase</code> 方法。</li>
<li><strong>查找元素</strong>：<code>find</code> 方法。</li>
<li><strong>遍历元素</strong>：使用迭代器或基于范围的 <code>for</code> 循环。</li>
</ol>
<h3 id="关联容器的迭代器"><a href="#关联容器的迭代器" class="headerlink" title="关联容器的迭代器"></a>关联容器的迭代器</h3><p>关联容器支持随机访问迭代器，迭代器的操作方式与其他容器类似。常用的迭代器包括：</p>
<ul>
<li>**begin()**：返回指向容器第一个元素的迭代器。</li>
<li>**end()**：返回指向容器尾后元素的迭代器。</li>
<li><strong>cbegin()</strong> 和 **cend()**：返回常量迭代器，不能用于修改元素。</li>
<li><strong>rbegin()</strong> 和 **rend()**：返回指向容器最后一个元素的反向迭代器。</li>
<li><strong>crbegin()</strong> 和 **crend()**：返回常量反向迭代器。</li>
</ul>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>向关联容器添加元素可以使用以下方法：</p>
<ul>
<li><strong>insert</strong>：在 <code>map</code> 和 <code>set</code> 中插入元素。</li>
<li><strong>emplace</strong>：直接在容器中构造元素，避免不必要的拷贝或移动。</li>
</ul>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; word_count;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向map插入元素</span></span><br><span class="line">    word_count.<span class="built_in">insert</span>(&#123;<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    word_count.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;world&quot;</span>, <span class="number">2</span>));</span><br><span class="line">    word_count.<span class="built_in">emplace</span>(<span class="string">&quot;cpp&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向set插入元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    numbers.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    numbers.<span class="built_in">emplace</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : word_count) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>从关联容器中删除元素的方法有：</p>
<ul>
<li><strong>erase</strong>：按迭代器、按键值或按键值范围删除元素。</li>
<li><strong>clear</strong>：删除容器中的所有元素。</li>
</ul>
<h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; word_count = &#123;&#123;<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;world&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;cpp&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键删除元素</span></span><br><span class="line">    word_count.<span class="built_in">erase</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按迭代器删除元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        numbers.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除范围内的元素</span></span><br><span class="line">    word_count.<span class="built_in">erase</span>(word_count.<span class="built_in">begin</span>(), word_count.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空set</span></span><br><span class="line">    numbers.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map-的下标访问"><a href="#map-的下标访问" class="headerlink" title="map 的下标访问"></a><code>map</code> 的下标访问</h3><p><code>map</code> 提供了下标操作符 <code>operator[]</code> 来访问和修改元素。如果键不存在，则插入一个新元素并初始化为默认值。</p>
<h4 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="type">int</span>&gt; word_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用下标访问元素</span></span><br><span class="line">    word_count[<span class="string">&quot;hello&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">    word_count[<span class="string">&quot;world&quot;</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    word_count[<span class="string">&quot;hello&quot;</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello: &quot;</span> &lt;&lt; word_count[<span class="string">&quot;hello&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;world: &quot;</span> &lt;&lt; word_count[<span class="string">&quot;world&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果键不存在，插入新元素并初始化为默认值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cpp: &quot;</span> &lt;&lt; word_count[<span class="string">&quot;cpp&quot;</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Chapter-12-动态内存"><a href="#Chapter-12-动态内存" class="headerlink" title="Chapter 12  动态内存"></a>Chapter 12  动态内存</h1>
        
      </div>

         
    </div>
    
     
  </div>
  
    

  
</article>





    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Alan Chen<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
